import os
import pandas as pd
import numpy as np
import pickle
import matplotlib.pyplot as plt
import statsmodels.api as sm
from statsmodels.sandbox.regression.predstd import wls_prediction_std

def clean_series(s):
    temp = s.copy()
    pat = r'[Uu][nN][kKs].*[nNd]$'
    temp[temp.str.contains(pat).values == 1] = np.nan
    temp = temp.cat.remove_unused_categories()
    return temp

def split_string(s, i):
    out = s.split('.')[i]
    try:
        out = int(out)
    except ValueError:
        out = np.nan
    return out



def read_clean(filename):
    """
    Reads the file and preprocesses it for the machine learning.
    :param filename: name of the file.
    :return: preprocessed pandas DataFrame
    """
    # Limiting the dtypes so the csv table could be read
    dtypes = {'MachineIdentifier': 'category',
              'ProductName': 'category',
              'EngineVersion': 'category',
              'AppVersion': 'category',
              'AvSigVersion': 'category',
              'IsBeta': 'int8',
              'RtpStateBitfield': 'float16',
              'IsSxsPassiveMode': 'int8',
              'DefaultBrowsersIdentifier': 'float16',
              'AVProductStatesIdentifier': 'float32',
              'AVProductsInstalled': 'float16',
              'AVProductsEnabled': 'float16',
              'HasTpm': 'int8',
              'CountryIdentifier': 'int16',
              'CityIdentifier': 'float32',
              'OrganizationIdentifier': 'float16',
              'GeoNameIdentifier': 'float16',
              'LocaleEnglishNameIdentifier': 'int8',
              'Platform': 'category',
              'Processor': 'category',
              'OsVer': 'category',
              'OsBuild': 'int16',
              'OsSuite': 'int16',
              'OsPlatformSubRelease': 'category',
              'OsBuildLab': 'category',
              'SkuEdition': 'category',
              'IsProtected': 'float16',
              'AutoSampleOptIn': 'int8',
              'PuaMode': 'category',
              'SMode': 'float16',
              'IeVerIdentifier': 'float16',
              'SmartScreen': 'category',
              'Firewall': 'float16',
              'UacLuaenable': 'float32',
              'Census_MDC2FormFactor': 'category',
              'Census_DeviceFamily': 'category',
              'Census_OEMNameIdentifier': 'float16',
              'Census_OEMModelIdentifier': 'float32',
              'Census_ProcessorCoreCount': 'float16',
              'Census_ProcessorManufacturerIdentifier': 'float16',
              'Census_ProcessorModelIdentifier': 'float16',
              'Census_ProcessorClass': 'category',
              'Census_PrimaryDiskTotalCapacity': 'float32',
              'Census_PrimaryDiskTypeName': 'category',
              'Census_SystemVolumeTotalCapacity': 'float32',
              'Census_HasOpticalDiskDrive': 'int8',
              'Census_TotalPhysicalRAM': 'float32',
              'Census_ChassisTypeName': 'category',
              'Census_InternalPrimaryDiagonalDisplaySizeInInches': 'float16',
              'Census_InternalPrimaryDisplayResolutionHorizontal': 'float16',
              'Census_InternalPrimaryDisplayResolutionVertical': 'float16',
              'Census_PowerPlatformRoleName': 'category',
              'Census_InternalBatteryType': 'category',
              'Census_InternalBatteryNumberOfCharges': 'float32',
              'Census_OSVersion': 'category',
              'Census_OSArchitecture': 'category',
              'Census_OSBranch': 'category',
              'Census_OSBuildNumber': 'int16',
              'Census_OSBuildRevision': 'int32',
              'Census_OSEdition': 'category',
              'Census_OSSkuName': 'category',
              'Census_OSInstallTypeName': 'category',
              'Census_OSInstallLanguageIdentifier': 'float16',
              'Census_OSUILocaleIdentifier': 'int16',
              'Census_OSWUAutoUpdateOptionsName': 'category',
              'Census_IsPortableOperatingSystem': 'int8',
              'Census_GenuineStateName': 'category',
              'Census_ActivationChannel': 'category',
              'Census_IsFlightingInternal': 'float16',
              'Census_IsFlightsDisabled': 'float16',
              'Census_FlightRing': 'category',
              'Census_ThresholdOptIn': 'float16',
              'Census_FirmwareManufacturerIdentifier': 'float16',
              'Census_FirmwareVersionIdentifier': 'float32',
              'Census_IsSecureBootEnabled': 'int8',
              'Census_IsWIMBootEnabled': 'float16',
              'Census_IsVirtualDevice': 'float16',
              'Census_IsTouchEnabled': 'int8',
              'Census_IsPenCapable': 'int8',
              'Census_IsAlwaysOnAlwaysConnectedCapable': 'float16',
              'Wdft_IsGamer': 'float16',
              'Wdft_RegionIdentifier': 'float16',
              'HasDetections': 'int8'}
    df = pd.read_csv(os.path.join('../data/raw/', filename), dtype=dtypes)
    num_cols = ['AVProductsInstalled', 'OsBuild', 'OsSuite', 'AutoSampleOptIn',
                'UacLuaenable', 'Census_ProcessorCoreCount',
                'Census_PrimaryDiskTotalCapacity',
                'Census_SystemVolumeTotalCapacity', 'Census_TotalPhysicalRAM',
                'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                'Census_InternalPrimaryDisplayResolutionHorizontal',
                'Census_InternalPrimaryDisplayResolutionVertical',
                'Census_InternalBatteryNumberOfCharges',
                'Census_OSBuildNumber', 'Census_OSBuildRevision']
    cat_cols = ['IsBeta', 'HasTpm', 'DefaultBrowsersIdentifier',
                'RtpStateBitfield', 'IsSxsPassiveMode', 'AVProductsEnabled',
                'IsProtected', 'SMode', 'Firewall', 'AVProductStatesIdentifier',
                'CountryIdentifier', 'CityIdentifier', 'OrganizationIdentifier',
                'GeoNameIdentifier', 'LocaleEnglishNameIdentifier', 'IeVerIdentifier',
                'Census_OEMNameIdentifier', 'Census_OEMModelIdentifier',
                'MachineIdentifier', 'ProductName', 'EngineVersion', 'AppVersion',
                'AvSigVersion', 'Platform', 'Processor', 'OsVer',
                'OsPlatformSubRelease', 'OsBuildLab', 'SkuEdition',
                'Census_ProcessorManufacturerIdentifier', 'PuaMode',
                'SmartScreen', 'Census_MDC2FormFactor', 'Census_DeviceFamily',
                'Census_OSInstallLanguageIdentifier', 'Census_OSUILocaleIdentifier',
                'Census_ProcessorClass', 'Census_PrimaryDiskTypeName',
                'Census_ChassisTypeName', 'Census_IsPortableOperatingSystem',
                'Census_PowerPlatformRoleName', 'Census_InternalBatteryType',
                'Census_OSVersion', 'Census_IsFlightingInternal',
                'Census_IsFlightsDisabled', 'Census_HasOpticalDiskDrive',
                'Census_IsSecureBootEnabled', 'Census_IsWIMBootEnabled',
                'Census_FirmwareManufacturerIdentifier',
                'Census_FirmwareVersionIdentifier', 'Census_ProcessorModelIdentifier',
                'Census_OSArchitecture', 'Census_OSBranch', 'Census_OSEdition',
                'Census_OSSkuName', 'Census_OSInstallTypeName',
                'Census_OSWUAutoUpdateOptionsName', 'Census_GenuineStateName',
                'Census_ActivationChannel', 'Census_FlightRing',
                'Census_IsVirtualDevice', 'Census_ThresholdOptIn',
                'Census_IsTouchEnabled', 'Census_IsPenCapable',
                'Census_IsAlwaysOnAlwaysConnectedCapable',
                'Wdft_IsGamer', 'Wdft_RegionIdentifier']
    df_cols = df.columns.tolist()
    if 'HasDetections' in df_cols:
        df_cols.remove('HasDetections')
    assert set(num_cols) | set(cat_cols) == set(df_cols)

    for c in ['EngineVersion', 'AppVersion', 'AvSigVersion', 'OsVer', 'Census_OSVersion']:
        for i in range(4):
            col_name = ''.join([c, '_', str(i)])
            df[col_name] = df[c].apply(split_string, i=i)
            if not col_name in num_cols:
                num_cols.append(col_name)

    OsBuildLab_cols = ['OsBuildLab_' + str(i) for i in range(6)]
    pat = r'^(\d+).(\d+).([a-z0-9]+).([a-z0-9_]+).(\d+)-(\d+)$'
    df[OsBuildLab_cols] = df['OsBuildLab'].str.extract(pat, expand=True)
    for i, col_name in enumerate(OsBuildLab_cols):
        if i in [0, 1, 4, 5]:
            df[col_name] = df[col_name].astype(float)
            if not col_name in num_cols:
                num_cols.append(col_name)
        else:
            df[col_name] = df[col_name].astype('category')
            if not col_name in cat_cols:
                cat_cols.append(col_name)

    pat0 = r'^([A-Za-z0-9]+)'
    df['Census_OSBranch_0'] = df['Census_OSBranch'].str.extract(pat0, expand=False).astype('category')
    pat1 = r'^[A-Za-z0-9]+[_ ]([A-Za-z0-9]+)'
    df['Census_OSBranch_1'] = df['Census_OSBranch'].str.extract(pat1, expand=False).astype('category')
    if not 'Census_OSBranch_0' in cat_cols:
        cat_cols.append('Census_OSBranch_0')
    if not 'Census_OSBranch_1' in cat_cols:
        cat_cols.append('Census_OSBranch_1')

    # Labeling missing values with np.nan
    for c in df.columns:
        if df[c].dtype.name == 'object':
            df[c] = df[c].astype('category')
        if df[c].dtype.name == 'category':
            df[c] = clean_series(df[c])


    with open('../data/interim/missing_cols_na_cols.pkl', 'rb') as f:
        missing_cols = pickle.load(f)
    for c in missing_cols:
        df[c + '_na'] = np.array(df[c].isna(), dtype=np.uint8)
    with open('../data/interim/cols_many_nans.pkl', 'rb') as f:
        cols_many_nans = pickle.load(f)
    imbalanced_cols = ['IsBeta', 'EngineVersion_0', 'EngineVersion_1', 'AppVersion_0',
        'AvSigVersion_0', 'AvSigVersion_3', 'Census_OSVersion_0', 'Census_OSVersion_1',
        'OsBuildLab_na', 'Census_OSSkuName_na', 'AvSigVersion_1_na', 'OsBuildLab_0_na',
        'OsBuildLab_1_na', 'OsBuildLab_2_na', 'OsBuildLab_3_na', 'OsBuildLab_4_na', 'OsBuildLab_5_na']
    labels_to_drop = [c for c in df.columns if c in cols_many_nans or c in imbalanced_cols]
    df.drop(labels=labels_to_drop, axis=1, inplace=True)
    num_cols = [c for c in num_cols if not c in labels_to_drop]
    cat_cols = [c for c in cat_cols if not c in labels_to_drop]

    with open('../data/interim/df_labels.pkl', 'rb') as f:
        df_labels = pickle.load(f)
    for c in cat_cols:
        if not c == 'MachineIdentifier' and not c == 'HasDetections' and not c in labels_to_drop:
            df[c] = df[c].map(df_labels[c])
            # filling the unmapped values with 0, which correspond to nan for categorical values
            df[c].fillna(value=0, inplace=True)
    with open('../data/interim/medians.pkl', 'rb') as f:
        medians = pickle.load(f)
    df.fillna(value=medians, inplace=True)

    return df

def frequencies_by_groups(df, groups, df_labels, remap=True):
    by_groups = df[groups].groupby(groups).size()
    by_groups.name = 'group_value_count'
    by_groups = by_groups.reset_index()
    by_group1_sum = df[groups].groupby(groups[0]).size()
    by_group1_sum.name = 'sum_by_{}'.format(groups[0])
    by_group1_sum = by_group1_sum.reset_index()
    by_groups_merged = by_groups.merge(by_group1_sum)
    by_groups_merged['frequency'] = by_groups_merged.group_value_count.divide(by_groups_merged['sum_by_{}'.format(groups[0])])
    if groups[0] in df_labels.keys() and remap:
        mapping = {v: k for k, v in df_labels[groups[0]].items()}
        by_groups_merged[groups[0]] = by_groups_merged[groups[0]].map(mapping)
    return by_groups_merged

def weighted_frequencies(df, feature, df_labels, remap=False):
    by_feature = frequencies_by_groups(df, [feature, 'HasDetections'], df_labels, remap=remap)
    by_feature_positive = by_feature.loc[by_feature['HasDetections'] == 1]
    y = by_feature_positive.frequency
    x = sm.add_constant(by_feature_positive[feature])
    weights = by_feature_positive.group_value_count
    wls_model = sm.WLS(
        y.astype(float),
        x.astype(float),
        weights=weights).fit()
    print(wls_model.summary())

    prstd, iv_l, iv_u = wls_prediction_std(wls_model)
    fig, ax = plt.subplots(figsize=(8,6))
    ax.plot(x[feature], y, 'o', label=feature)
    ax.plot(x[feature], wls_model.fittedvalues, 'r-')
    plt.fill_between(x[feature], iv_l, iv_u, color='red', alpha=.2)
    plt.ylim(-.2, 1.2)
    plt.xlabel(feature)
    plt.ylabel('"HasDetections" fraction')
    plt.title('"HasDetection" fraction by "{}"'.format(feature));
    plt.savefig('../reports/figures/by_{}.pdf'.format(feature))
